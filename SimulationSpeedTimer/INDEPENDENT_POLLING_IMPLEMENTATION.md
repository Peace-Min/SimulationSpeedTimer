# 독립적 폴링(Independent Polling) 아키텍처 구현

## 1. 핵심 개념: 독립적 데이터 폴링
기존의 "전역 동기화 대기(Global Synchronized Wait)" 모델에서 **"독립적 폴링(Independent Polling)"** 모델로 전환하여, 서로 다른 속도로 업데이트되는 테이블 간의 레이스 컨디션(Race Condition)과 데드락(Deadlock) 문제를 제거했습니다.

### 주요 메커니즘
- **테이블별 커서(Per-Table Cursors)**: `GlobalDataService`는 각 테이블별로 별도의 `s_time` 커서를 관리합니다.
- **비차단 조회(Non-Blocking Fetch)**:
  - 매 주기마다 작업자(Worker)는 각 테이블에 대해 `[내 커서, 목표 시간]` 범위의 데이터를 확인합니다.
  - **데이터가 있음**: 데이터를 가져오고 해당 테이블의 커서를 업데이트합니다.
  - **데이터가 없음**: **아무것도 하지 않습니다.** 대기(Wait)하거나 즉시 재시도(Retry)하지 않고 그냥 건너뜁니다.
  - 커서가 변경되지 않았으므로, 다음 루프에서 자연스럽게 누락된 구간을 다시 조회하게 됩니다.
- **결과**: 빠른 테이블(예: 100ms 간격)은 즉시 조회되고, 느린 테이블(예: 500ms 간격)은 데이터가 도착했을 때 조회되며, 전체 시스템을 차단하지 않습니다.

## 2. 데이터 병합 및 동기화 (Data Merging & Synchronization)
데이터가 독립적으로, 그리고 순서 없이 도착하므로 다운스트림 컴포넌트는 부분적인 업데이트를 처리해야 합니다.

### 병합 전략
- **`SimulationFrame.Merge(otherFrame)`**:
  - 서로 다른 조회 주기에서 가져온 데이터를 결합할 수 있도록 구현되었습니다.
  - `SharedFrameRepository`에 시간 `T`의 프레임이 이미 존재한다면, 시간 `T`에 대한 새로운 테이블 데이터가 도착했을 때 기존 프레임에 **병합(Merge)**됩니다.
  - 이를 통해 모든 테이블이 데이터를 보고하면 결국 `SimulationFrame`이 완성됩니다.
- **저장소 로직**:
  - `StoreChunk`는 이제 덮어쓰기(Overwrite) 대신 `Merge`를 사용하여, 기존 데이터를 보존하면서 새로운 데이터를 추가합니다.

## 3. 우아한 종료 (Graceful Shutdown - Final Sweep)
시뮬레이션 종료 시 데이터 유실(특히 늦게 도착하는 테이블 데이터)을 방지하기 위함입니다.

- **종료 시간 포착**: `Stop()`이 호출되면 서비스는 `lastSeenTime`(마지막 요청 시간)을 기록합니다.
- **마지막 루프**: 메인 루프가 종료되기 직전, `lastSeenTime`까지 한 번 더 `ProcessRange`를 호출합니다.
- **목적**: 종료 신호를 받는 시점에 DB에 막 커밋된 "잔여 데이터"를 가져오기 위함입니다.

## 4. UI 및 차트 처리
- **인위적 데이터 없음**: 차트는 누락된 테이블에 대해 `NaN`이나 가짜 데이터를 주입하지 않습니다. 데이터가 도착할 때까지 점을 찍지 않습니다.
- **X축 연속성**: 차트의 X축(시간 기반일 경우)은 전역 시뮬레이션 시간에 의해 구동되므로, 특정 시리즈 데이터가 지연되더라도 뷰포트는 부드럽게 스크롤됩니다.

---
**요약**: 이 아키텍처는 즉각적인 일관성보다는 **시스템 안정성과 반응성**을 우선시하여, 하나의 느린 컴포넌트가 전체 시뮬레이션 재생을 멈추게 하는 것을 방지합니다.
